


https://edube.org

object programming. 
procedural programming.

The object approach suggests a completely different way of thinking. 
The data and the code are enclosed together 
in the same world, 
divided into classes. 

Every class is like a recipe that can be used when you want to create a useful object 
  
Every object has a set of traits (they‚Äôre called properties) and 
is able to perform a set of activities (which are called methods).


Objects are incarnations of ideas expressed in classes, 
much like a piece of cheesecake on your plate is an incarnation of an idea 
expressed in the recipe printed in an old cookbook. 

inheritance
Any object bound to a specific level of a class hierarchy inherits all the traits 
(as well as requirements and qualities) defined inside any of the superclasses.

every existing object may be equipped with three groups of attributes
a noun, you probably define the object‚Äôs name
an adjective, you probably define the object‚Äôs property
a verb, you probably define the object‚Äôs activity
"Max is a large cat who sleeps all day"
Object name = Max
Home class = Cat
Property = Size (large)
Activity = Sleep (all day)



stack, lifo
lilo?

A class is an aggregate 
consisting of variables (also called fields or properties) and 
functions (sometimes called methods). 
Both variables and functions are class components.


THIS pointer
class Class {
public:
    void setVal(int value) { 
            Class::value = value;
    }
    int getVal(void);
private:
    int value;
};
class Class {
public:
    Class(void) { this -> value = -1; } //constructor
    Class(int val) { this -> value = val; } //constructor overload
    void setVal(int value) { 
           this -> value = value;
    }
     void setVal(void) { value = -2; } //func overload
     int getVal(void);
    ~Class(void) { //destructor
	delete [] value;
	cout << "Deletion done." << endl;
    }
private:
     int value;
};
int Class::getVal(void) { //outside def "::"
      return value;
}

int main(void) {
	Class1 object11(100), object12 = object11; // object copy
	Class2 object21(200), object22 = object21;
	Class1 object1_ = 10;//implicit conversion  object1_ = Class1(10)
	cout << object12.value << endl;
	cout << object22.value << endl;
	return 0;
}




There‚Äôs another important fact worth mentioning: the constructors aren‚Äôt real functions. 
They don‚Äôt have any return type ‚Äì not even void. 
You need to take this into consideration when declaring or defining a new constructor.



auto keyword---see auto.cpp


A static component exists throughout the whole life of the program. Moreover, there is always only one component regardless of the number of instances of the class.
We can say that all the instances share the same static components.
#include <iostream>
using namespace std;
class Class {
	//static int Counter; //lehet itt is privatban
public:
	static int Counter; //minden peldanynak ua
	Class(void) { ++Counter; };
	~Class(void) { 
		--Counter; 
		if(Counter == 0) cout << "Bye, bye!" << endl; 
	};
	static void HowMany(void) { cout << Counter << " instances" << endl; } //static func, minden peldanynak ua
};
int Class::Counter = 0;
int main(void) {
	Class a;
	Class b;
	cout << Class::Counter << " instances so far" << endl;
	Class c;
	Class d;
	d.HowMany();
	return 0;
}

****************************************


#include <iostream>
using namespace std;

class Test {
public:
    static void funS1(void) { cout << "static" << endl; }
    static void funS2(void) { funS1(); }
};

int main(void) {
    Test object;
    /* !!! --->    // a static func es a static var peldanyositas nelkul is helyet foglal a memoriaban */
    Test::funS2(); //Can be called using ClassName::FunctionName() without creating an object.    
    object.funS2();
    return 0;
}


    a static component accesses a static component         ---> OK
    a static component accesses a non-static component     ---> notOK
    a non-static component accesses a static component     ---> OK
    a non-static component accesses a non-static component ---> OK



Pointers to objects
So far we‚Äôve treated objects like ordinary variables and 
assumed that an object is created in the place where it is declared and 
destroyed when its declaration scope is exited. <----!!!!!!!! tesztelni
This is only one of the many possible object incarnations.

Objects may also exist as dynamically created and destroyed entities. 
In other words, objects may appear on demand ‚Äì when they‚Äôre needed ‚Äì and vanish in the same way.
#include <iostream>
using namespace std;
class Class {
public:
	Class(void) {
		cout << "Object constructed!" << endl;
	}
	~Class(void) {
		cout << "Object destructed!" << endl;
	}
	void IncAndPrint(void) {
		cout << "value = " << ++value << endl;
	}
	int value;
};	
int main(void) {
	Class *ptr;
	
	ptr = new Class;
	ptr -> value = 1;
	ptr -> IncAndPrint();
	delete ptr;
	return 0;
}

!!! All the variables, including objects, brought to life in the ‚Äúordinary‚Äù way 
(by declaration, not by the use of the new keyword) 
live in a separate area of memory called the stack. 
It‚Äôs a memory region dedicated to storing all automatic entities.

The entities created ‚Äúon demand‚Äù (by the new keyword) are created in a specific memory region usually called a heap. 
In contrary to the stack, the heap is fully (almost fully, to be honest) under your control. 
You decide how many variables, arrays, objects, etc. will occupy the heap and it‚Äôs up to you when these entities end their lives.

The object being stored in the heap must be accessed in a way that resembles the access to the dynamically allocated structures. 
You mustn‚Äôt use the ordinary ‚Äúdotted‚Äù notation as there‚Äôs no structure (object) 
which can play the role of the left argument of the ‚Äú.‚Äù operator 
unless you dereference the pointer. You need to use the ‚Äúarrow‚Äù (->) operator instead.

The conclusion is: constructors from inner objects (objects stored inside other objects) are invoked before the outer object‚Äôs constructors start their work.
list all the inner objects‚Äô constructors
#include <iostream>
using namespace std;
class Element {
	int value;
public:
	Element(int val) {
		value = val; cout << "Element(" << val << ") constructed!" << endl;
	}
	int Get(void) { return value; }
	void Put(int val) { value = val; }
};
class Collection {
	Element el1, el2;
public:
	Collection(void) : el2(2), el1(1) { cout << "Collection constructed!" << endl; } //<------!!!!
	int Get(int elno) { return elno == 1 ? el1.Get() : el2.Get(); }
	int Put(int elno, int val) { if(elno == 1) el1.Put(val); else el2.Put(val); }
};
int main(void) {
	Collection coll;
	return 0;
}

********************
practice test

Here is a **C++ Intermediate Test** with a balanced mix of concepts: OOP, templates, STL, memory management, modern C++ (11‚Äì20), pointers/references, and tricky language details.
**Answers and explanations included.**

---

# ‚úÖ **C++ Intermediate Test (with Answers)**

## **Section A ‚Äî Multiple Choice (10 questions)**

### **1. What is the output of the following code?**

```cpp
int x = 10;
auto f = [x]() mutable { x += 5; return x; };
cout << f() << " " << x;
```

**A.** `15 10`
**B.** `15 15`
**C.** `10 10`
**D.** Compilation error

‚úî **Answer: A**
`mutable` makes a copy of `x` modifiable inside the lambda. The original `x` remains unchanged.

---

### **2. Which RAII principle is correct?**

**A.** Constructors acquire resources, destructors release them
**B.** Destructors acquire resources, constructors release them
**C.** Resources must be manually managed via `malloc` and `free`
**D.** RAII only works with smart pointers

‚úî **Answer: A**

---

### **3. What does this program print?**

```cpp
vector<int> v = {1,2,3,4};
v.erase(v.begin() + 1, v.begin() + 3);
for (int x : v) cout << x;
```

**A.** `1234`
**B.** `14`
**C.** `134`
**D.** `12`

‚úî **Answer: B**
Erases elements at indexes 1 and 2 ‚Üí removes `2` and `3`.

---

### **4. What is `std::move`?**

**A.** Forces a deep copy
**B.** Casts to rvalue reference
**C.** Deletes the object after use
**D.** Moves objects automatically

‚úî **Answer: B**

---

### **5. Which smart pointer allows shared ownership?**

**A.** `std::unique_ptr`
**B.** `std::shared_ptr`
**C.** `std::weak_ptr`
**D.** All of the above

‚úî **Answer: B**

---

### **6. What is the output?**

```cpp
int a = 5;
int& r = a;
auto x = r;
x = 10;
cout << a;
```

**A.** 5
**B.** 10
**C.** Undefined
**D.** Compilation error

‚úî **Answer: A**
`auto` deduces a **copy** of `r`, not a reference.

---

### **7. Which keyword prevents a class from being inherited?**

**A.** `sealed`
**B.** `final`
**C.** `private`
**D.** `static`

‚úî **Answer: B**

---

### **8. What does this code do?**

```cpp
template<typename T>
void f(T&& x);
```

**A.** Always takes rvalues
**B.** Always takes lvalues
**C.** Uses universal (forwarding) references
**D.** Declares an error

‚úî **Answer: C**

---

### **9. What is wrong with this code?**

```cpp
string* s = new string("hi");
throw s;
```

**A.** Exception must be primitive
**B.** Memory leak risk
**C.** Cannot throw pointers
**D.** Throw must be inside try

‚úî **Answer: B**

---

### **10. In multithreading, `std::lock_guard` is used for:**

**A.** Lazy initialization
**B.** Creating a mutex
**C.** Exception-safe locking
**D.** Unlocking only

‚úî **Answer: C**

---

---

# ‚ú≥ **Section B ‚Äî Short Answer (5 Questions)**

### **11. What is ‚Äúundefined behavior‚Äù? Give a small example.**

‚úî **Answer:**
Behavior not defined by the C++ standard; anything can happen.

Example:

```cpp
int x = 5;
int* p = &x;
delete p;   // UB: deleting stack memory
```

---

### **12. What is the difference between `override` and `final`?**

‚úî **Answer:**

* `override`: ensures a method overrides a virtual one.
* `final`: prevents further overriding (for methods) or inheritance (for classes).

---

### **13. What is the difference between `std::list` and `std::vector`?**

‚úî **Answer:**

* `vector`: contiguous memory, fast random access
* `list`: node-based, fast insertion/deletion at any position

---

### **14. What is ‚Äúmove semantics‚Äù in C++?**

‚úî **Answer:**
Optimizes performance by transferring resources from temporary objects instead of copying them. Uses rvalue references (`T&&`).

---

### **15. Why are virtual destructors important?**

‚úî **Answer:**
To ensure correct cleanup when deleting a derived object through a base-class pointer.

---

---

# üîß **Section C ‚Äî Coding Questions**

## **16. Predict the output**

```cpp
struct A {
    A() { cout << "A "; }
    A(const A&) { cout << "C "; }
    A(A&&) { cout << "M "; }
};

A make() {
    A a;
    return a;
}

int main() {
    A x = make();
}
```

‚úî **Answer:**
`A M` (likely, due to NRVO + move ctor)
‚Äî or just `A` if NRVO fully eliminates the move (depending on compiler).

---

## **17. Fix the following code (bug: memory leak + double free risk)**

```cpp
int* p = new int(10);
shared_ptr<int> sp(p);
shared_ptr<int> sp2(p);
```

‚úî **Corrected version:**

```cpp
auto sp = make_shared<int>(10);
auto sp2 = sp;
```

Using `make_shared` avoids double deletion.

---

## **18. Write a function template `maxOf` that returns the larger of two values.**

‚úî **Answer:**

```cpp
template<typename T>
T maxOf(const T& a, const T& b) {
    return (a > b) ? a : b;
}
```

---

## **19. What does this code print?**

```cpp
int a = 1;
int b = 2;
int&& r = std::move(a);
r = 5;
cout << a << " " << b;
```

‚úî **Answer:**
`5 2`
`r` refers to `a` even though it is an rvalue reference.

---

## **20. Explain what `emplace_back` does in `std::vector`.**

‚úî **Answer:**
Constructs the element **in place** without temporary copies, passing arguments directly to the element‚Äôs constructor.

---

---

# üéâ **If you want more:**

I can generate:

* Harder C++ test
* Object-oriented only test
* STL-only test
* Test without answers
* Test with explanations only
* Interview-style C++ challenges

Just tell me!

